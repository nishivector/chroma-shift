<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chroma Shift</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Orbitron', monospace;
        }
        
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #dimension-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        
        .dim-box {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            opacity: 0.4;
        }
        
        .dim-box.active {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 20px currentColor;
        }
        
        .dim-box.red { 
            color: #ff0066; 
            border-color: #ff0066;
            background: rgba(255,0,102,0.2);
        }
        .dim-box.blue { 
            color: #00ffff; 
            border-color: #00ffff;
            background: rgba(0,255,255,0.2);
        }
        .dim-box.green { 
            color: #00ff66; 
            border-color: #00ff66;
            background: rgba(0,255,102,0.2);
        }
        
        #score-display {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        #cooldown-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        #cooldown-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0066, #00ffff, #00ff66);
            transition: width 0.1s linear;
        }
        
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 36px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 0 0 20px currentColor;
        }
        
        #message.show {
            opacity: 1;
        }
        
        #controls-hint {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            text-align: center;
        }
        
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            pointer-events: auto;
            display: none;
        }
        
        .joystick-zone {
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            position: relative;
        }
        
        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: background 0.2s;
        }
        
        .joystick-knob.active {
            background: rgba(255,255,255,0.6);
        }
        
        #dimension-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            gap: 10px;
            pointer-events: auto;
        }
        
        .dim-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid;
            background: rgba(0,0,0,0.5);
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .dim-btn:active {
            transform: scale(0.9);
        }
        
        .dim-btn.red { color: #ff0066; border-color: #ff0066; }
        .dim-btn.blue { color: #00ffff; border-color: #00ffff; }
        .dim-btn.green { color: #00ff66; border-color: #00ff66; }
        
        @media (pointer: coarse) {
            #mobile-controls, #dimension-buttons {
                display: flex;
            }
            #controls-hint {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui-overlay">
        <div id="dimension-indicator">
            <div class="dim-box red" data-dim="0">1</div>
            <div class="dim-box blue" data-dim="1">2</div>
            <div class="dim-box green active" data-dim="2">3</div>
        </div>
        
        <div id="score-display">CRYSTALS: <span id="score">0</span></div>
        
        <div id="cooldown-bar">
            <div id="cooldown-fill"></div>
        </div>
        
        <div id="message"></div>
        
        <div id="controls-hint">
            WASD/Arrows: Move | Space: Jump | 1/2/3: Switch Dimension | R: Restart
        </div>
        
        <div id="mobile-controls">
            <div class="joystick-zone">
                <div class="joystick-knob" id="joystick"></div>
            </div>
        </div>
        
        <div id="dimension-buttons">
            <button class="dim-btn red" data-dim="0">1</button>
            <button class="dim-btn blue" data-dim="1">2</button>
            <button class="dim-btn green" data-dim="2">3</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Audio
        let audioCtx, gainNode;
        
        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);
            gainNode.gain.value = 0.3;
        }
        
        function playTone(freq, type = 'sine', duration = 0.2) {
            if (!audioCtx) initAudio();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(gainNode);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }
        
        function playDimensionSwitch(dim) {
            const freqs = [220, 330, 440];
            playTone(freqs[dim], 'sawtooth', 0.3);
        }
        
        function playCollect() {
            playTone(880, 'sine', 0.15);
            setTimeout(() => playTone(1100, 'sine', 0.15), 50);
        }
        
        function playWin() {
            [523, 659, 784, 1047].forEach((f, i) => {
                setTimeout(() => playTone(f, 'sine', 0.3), i * 100);
            });
        }

        // Game state
        const state = {
            dimension: 2, // 0=red, 1=blue, 2=green
            cooldown: 0,
            score: 0,
            velocity: new THREE.Vector3(),
            grounded: false,
            gameOver: false
        };
        
        const GRAVITY = { 0: 2, 1: 0.5, 2: 9.8 };
        const DIM_COLORS = {
            0: { primary: 0xff0066, secondary: 0xff66b2, ambient: 0x330011 },
            1: { primary: 0x00ffff, secondary: 0x0066ff, ambient: 0x001133 },
            2: { primary: 0x00ff66, secondary: 0x66ff00, ambient: 0x003311 }
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a0f, 10, 50);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 10);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.8, 0.4, 0.85
        );
        composer.addPass(bloomPass);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);
        
        const dimLight = new THREE.PointLight(DIM_COLORS[2].primary, 2, 20);
        dimLight.position.set(0, 5, 0);
        scene.add(dimLight);

        // Floor grid
        const gridHelper = new THREE.GridHelper(100, 100, 0x222233, 0x111122);
        scene.add(gridHelper);

        // Player
        const playerGeom = new THREE.SphereGeometry(0.5, 32, 32);
        const playerMat = new THREE.MeshStandardMaterial({
            color: DIM_COLORS[2].primary,
            emissive: DIM_COLORS[2].primary,
            emissiveIntensity: 0.5,
            metalness: 0.3,
            roughness: 0.4
        });
        const player = new THREE.Mesh(playerGeom, playerMat);
        player.position.set(0, 1, 0);
        scene.add(player);

        // Player glow
        const glowGeom = new THREE.SphereGeometry(0.6, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({
            color: DIM_COLORS[2].primary,
            transparent: true,
            opacity: 0.2
        });
        const playerGlow = new THREE.Mesh(glowGeom, glowMat);
        player.add(playerGlow);

        // Platforms
        const platforms = [];
        const crystals = [];
        
        function createPlatform(x, y, z, w, h, d, dim = null) {
            const geom = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({
                color: dim === null ? 0x444466 : DIM_COLORS[dim].primary,
                emissive: dim === null ? 0x000000 : DIM_COLORS[dim].primary,
                emissiveIntensity: dim === null ? 0 : 0.3,
                metalness: 0.5,
                roughness: 0.5,
                transparent: dim !== null,
                opacity: dim !== null ? 0.7 : 1
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(x, y, z);
            mesh.userData = { dim, width: w, height: h, depth: d };
            scene.add(mesh);
            platforms.push(mesh);
            return mesh;
        }
        
        function createCrystal(x, y, z) {
            const geom = new THREE.OctahedronGeometry(0.3);
            const mat = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.8,
                metalness: 0.8,
                roughness: 0.2
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(x, y, z);
            mesh.userData = { collected: false };
            scene.add(mesh);
            crystals.push(mesh);
            return mesh;
        }

        // Level design
        // Starting platform (green - always visible)
        createPlatform(0, 0, 0, 4, 0.5, 4, 2);
        
        // Red dimension platforms (upward gravity)
        createPlatform(0, 3, -5, 3, 0.5, 3, 0);
        createPlatform(-4, 6, -8, 3, 0.5, 3, 0);
        createPlatform(0, 9, -12, 3, 0.5, 3, 0);
        
        // Blue dimension platforms (slow motion)
        createPlatform(4, 2, -5, 3, 0.5, 3, 1);
        createPlatform(6, 4, -10, 3, 0.5, 3, 1);
        createPlatform(4, 6, -15, 3, 0.5, 3, 1);
        
        // Green dimension platforms (normal)
        createPlatform(0, 1, -8, 3, 0.5, 3, 2);
        createPlatform(-3, 3, -12, 3, 0.5, 3, 2);
        createPlatform(0, 5, -16, 3, 0.5, 3, 2);
        
        // Goal platform
        const goalPlatform = createPlatform(0, 7, -20, 5, 0.5, 5, 2);
        goalPlatform.material.color.setHex(0xffd700);
        goalPlatform.material.emissive.setHex(0xffd700);
        
        // Crystals
        createCrystal(0, 2, -5);
        createCrystal(-4, 5, -8);
        createCrystal(0, 8, -12);
        createCrystal(4, 3, -5);
        createCrystal(6, 5, -10);
        createCrystal(0, 2, -8);
        createCrystal(-3, 4, -12);
        
        // Input
        const keys = {};
        const joystickInput = { x: 0, y: 0 };
        
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Digit1') switchDimension(0);
            if (e.code === 'Digit2') switchDimension(1);
            if (e.code === 'Digit3') switchDimension(2);
            if (e.code === 'KeyR') restartGame();
        });
        
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Mobile controls
        const joystick = document.getElementById('joystick');
        const joystickZone = joystick.parentElement;
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        
        joystickZone.addEventListener('touchstart', e => {
            e.preventDefault();
            joystickActive = true;
            const rect = joystickZone.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
            joystick.classList.add('active');
        });
        
        window.addEventListener('touchmove', e => {
            if (!joystickActive) return;
            const touch = e.touches[0];
            const dx = touch.clientX - joystickCenter.x;
            const dy = touch.clientY - joystickCenter.y;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 35);
            const angle = Math.atan2(dy, dx);
            joystickInput.x = Math.cos(angle) * (dist / 35);
            joystickInput.y = Math.sin(angle) * (dist / 35);
            joystick.style.transform = `translate(calc(-50% + ${joystickInput.x * 35}px), calc(-50% + ${joystickInput.y * 35}px))`;
        });
        
        window.addEventListener('touchend', () => {
            joystickActive = false;
            joystickInput.x = 0;
            joystickInput.y = 0;
            joystick.style.transform = 'translate(-50%, -50%)';
            joystick.classList.remove('active');
        });
        
        // Dimension buttons
        document.querySelectorAll('.dim-btn').forEach(btn => {
            btn.addEventListener('touchstart', e => {
                e.preventDefault();
                switchDimension(parseInt(btn.dataset.dim));
            });
        });

        function switchDimension(dim) {
            if (state.cooldown > 0 || dim === state.dimension || state.gameOver) return;
            
            state.dimension = dim;
            state.cooldown = 0.5;
            
            const colors = DIM_COLORS[dim];
            playerMat.color.setHex(colors.primary);
            playerMat.emissive.setHex(colors.primary);
            glowMat.color.setHex(colors.primary);
            dimLight.color.setHex(colors.primary);
            
            document.querySelectorAll('.dim-box').forEach((box, i) => {
                box.classList.toggle('active', i === dim);
            });
            
            // Update platform visibility
            platforms.forEach(p => {
                if (p.userData.dim === null) {
                    p.visible = true;
                } else {
                    p.visible = p.userData.dim === dim;
                }
            });
            
            playDimensionSwitch(dim);
        }

        function showMessage(text, color) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.color = color;
            msg.classList.add('show');
            setTimeout(() => msg.classList.remove('show'), 2000);
        }

        function restartGame() {
            player.position.set(0, 1, 0);
            state.velocity.set(0, 0, 0);
            state.score = 0;
            state.gameOver = false;
            state.dimension = 2;
            switchDimension(2);
            document.getElementById('score').textContent = '0';
            crystals.forEach(c => {
                c.userData.collected = false;
                c.visible = true;
            });
        }

        function checkCollisions() {
            state.grounded = false;
            
            platforms.forEach(p => {
                if (!p.visible) return;
                
                const pw = p.userData.width / 2;
                const ph = p.userData.height / 2;
                const pd = p.userData.depth / 2;
                
                const px = p.position.x;
                const py = p.position.y;
                const pz = p.position.z;
                
                // Simple AABB collision
                if (player.position.x > px - pw - 0.4 &&
                    player.position.x < px + pw + 0.4 &&
                    player.position.z > pz - pd - 0.4 &&
                    player.position.z < pz + pd + 0.4) {
                    
                    // Check vertical collision
                    const playerBottom = player.position.y - 0.5;
                    const playerTop = player.position.y + 0.5;
                    const platTop = py + ph;
                    const platBottom = py - ph;
                    
                    // Landing on top
                    if (playerBottom <= platTop && playerBottom >= platTop - 0.5 && state.velocity.y <= 0) {
                        player.position.y = platTop + 0.5;
                        state.velocity.y = 0;
                        state.grounded = true;
                    }
                    // Hitting from below
                    else if (playerTop >= platBottom && playerTop <= platBottom + 0.5 && state.velocity.y > 0) {
                        player.position.y = platBottom - 0.5;
                        state.velocity.y = 0;
                    }
                }
            });
            
            // Crystal collection
            crystals.forEach(c => {
                if (c.userData.collected) return;
                if (player.position.distanceTo(c.position) < 0.8) {
                    c.userData.collected = true;
                    c.visible = false;
                    state.score++;
                    document.getElementById('score').textContent = state.score;
                    playCollect();
                }
            });
            
            // Goal check
            if (player.position.z < -17 && player.position.y > 6 && state.dimension === 2) {
                if (!state.gameOver) {
                    state.gameOver = true;
                    playWin();
                    showMessage(`LEVEL COMPLETE! Score: ${state.score}`, '#ffd700');
                }
            }
            
            // Fall reset
            if (player.position.y < -10) {
                player.position.set(0, 1, 0);
                state.velocity.set(0, 0, 0);
            }
        }

        // Game loop
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1);
            
            if (!state.gameOver) {
                // Cooldown
                if (state.cooldown > 0) {
                    state.cooldown -= delta;
                    document.getElementById('cooldown-fill').style.width = `${(1 - state.cooldown / 0.5) * 100}%`;
                } else {
                    document.getElementById('cooldown-fill').style.width = '100%';
                }
                
                // Input
                const moveSpeed = 8;
                const moveX = (keys['KeyD'] || keys['ArrowRight'] ? 1 : 0) - (keys['KeyA'] || keys['ArrowLeft'] ? 1 : 0) + joystickInput.x;
                const moveZ = (keys['KeyW'] || keys['ArrowUp'] ? 1 : 0) - (keys['KeyS'] || keys['ArrowDown'] ? 1 : 0) + joystickInput.y;
                
                state.velocity.x = moveX * moveSpeed;
                state.velocity.z = moveZ * moveSpeed;
                
                // Gravity
                const gravity = GRAVITY[state.dimension];
                if (state.dimension === 0) {
                    // Red: reverse gravity (float up)
                    state.velocity.y += gravity * delta;
                } else {
                    state.velocity.y -= gravity * delta;
                }
                
                // Jump
                if ((keys['Space']) && state.grounded) {
                    state.velocity.y = state.dimension === 0 ? 8 : (state.dimension === 1 ? 3 : 8);
                    state.grounded = false;
                }
                
                // Apply velocity
                player.position.x += state.velocity.x * delta;
                player.position.y += state.velocity.y * delta;
                player.position.z += state.velocity.z * delta;
                
                checkCollisions();
                
                // Camera follow
                camera.position.x += (player.position.x - camera.position.x) * 0.05;
                camera.position.y += (player.position.y + 3 - camera.position.y) * 0.05;
                camera.position.z += (player.position.z + 8 - camera.position.z) * 0.05;
                camera.lookAt(player.position);
            }
            
            // Crystal rotation
            crystals.forEach(c => {
                c.rotation.y += delta * 2;
                c.position.y += Math.sin(clock.elapsedTime * 2 + c.position.x) * 0.005;
            });
            
            // Player glow pulse
            playerGlow.scale.setScalar(1 + Math.sin(clock.elapsedTime * 3) * 0.1);
            
            composer.render();
        }
        
        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start
        initAudio();
        animate();
    </script>
</body>
</html>
